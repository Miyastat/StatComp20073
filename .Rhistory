test<-n*b/6
chi<-qchisq(0.95,c*(c+1)*(c+2)/6)
as.integer(test>chi)
}
set.seed(1234)
mu <- c(0,0,0)
sigma <- matrix(c(1,0,0,0,1,0,0,0,1),nrow=3,ncol=3)
m=1000
n<-c(10, 20, 30, 50, 100, 500)
#m: number of replicates; n: sample size
a=numeric(length(n))
for(i in 1:length(n)){
a[i]=mean(replicate(m, expr={
mydata <- mvrnorm(n[i],mu,sigma)
Mardia(mydata)
}))
}
Mardia.test <- function(X) {
n <- nrow(X)
c <- ncol(X)
mydata <- X
for(i in 1:c){
mydata[,i]<-X[,i]-mean(X[,i])
}
sigmah<-t(mydata)%*%mydata/n
a<-mydata%*%solve(sigmah)%*%t(mydata)
b<-sum(colSums(a^{3}))/(n*n)
test<-n*b/6
chi<-qchisq(0.95,c*(c+1)*(c+2)/6)
as.integer(test>chi)
}
library(MASS)
set.seed(1234)
mu <- c(0,0,0)
sigma <- matrix(c(1,0,0,0,1,0,0,0,1),nrow=3,ncol=3)
m=1000
n<-c(10, 20, 30, 50, 100, 500)
#m: number of replicates; n: sample size
p.reject=numeric(length(n))
for(i in 1:length(n)){
a[i]=mean(replicate(m, expr={
X <- mvrnorm(n[i],mu,sigma)
Mardia.test(X)
}))
}
for(i in 1:length(n)){
p.reject[i]=mean(replicate(m, expr={
X <- mvrnorm(n[i],mu,sigma)
Mardia.test(X)
}))
}
print(p.reject)
?dt
knitr::opts_chunk$set(echo = TRUE)
library(lattice)
library(DAAG)
attach(ironslag)
# t(v)
pwr_t = function(v){
alpha = 0.1
n = 20
m = 1e3
N = length(v)
pwr = numeric(N)
cv = qnorm(1-alpha/2, 0, sqrt(6*(n-2) / ((n+1)*(n+3))))
for (j in 1:N) {
sktests = numeric(m)
for (i in 1:m) {
x = rt(n,v[j])
sktests[i] = as.integer(abs(sk(x))>= cv)
}
pwr[j] = mean(sktests)
}
se = sqrt(pwr*(1-pwr) / m)
return(list(pwr = pwr,se = se))
}
v = seq(1,20)
pwr = pwr_t(v)$pwr
se = pwr_t(v)$se
#first write a function to compute the sample skewness coeff
sk <- function(x) {
xbar <- mean(x)
m3 <- mean((x - xbar)^3)
m2 <- mean((x - xbar)^2)
return( m3 / m2^1.5 )
}
pwr = pwr_t(v)$pwr
se = pwr_t(v)$se
# plot the power
plot(v, pwr, type = "b", xlab = "v", ylab = "pwr", ylim = c(0,1),pch=16)
# plot the power
plot(v, pwr, type = "b", xlab = "v", ylab = "pwr", ylim = c(0,1),pch=16)
abline(h = 0.1, lty = 2)
# plot the power
plot(v, pwr, type = "b", xlab = "v", ylab = "pwr", ylim = c(0,1),pch=16)
abline(h = 0.1, lty = 2)
lines(v, pwr+se, lty = 4)
lines(v, pwr-se, lty = 4)
# plot the power
plot(v, pwr, type = "b", xlab = "v", ylab = "pwr", ylim = c(0,1),pch=16)
abline(h = 0.1, lty = 2)
pwr_t = function(v){
alpha = 0.1
n = 20
m = 1e3
N = length(v)
pwr = numeric(N)
cv = qnorm(1-alpha/2, 0, sqrt(6*(n-2) / ((n+1)*(n+3))))
for (j in 1:N) {
sktests = numeric(m)
for (i in 1:m) {
x = rt(n,v[j])
sktests[i] = as.integer(abs(sk(x))>= cv)
}
pwr[j] = mean(sktests)
}
se = sqrt(pwr*(1-pwr) / m)
return(list(pwr = pwr,se = se))
}
v = seq(1,20)
pwr = pwr_t(v)$pwr
se = pwr_t(v)$se
# plot the power
plot(v, pwr, type = "b", xlab = "v", ylab = "pwr", ylim = c(0,1),pch=16)
abline(h = 0.1, lty = 2)
lines(v, pwr+se, lty = 4)
lines(v, pwr-se, lty = 4)
library(Rcpp)
dir_cpp <- '../src/'
sourceCpp(paste0(dir_cpp,"MetropolisC.cpp"))
sourceCpp(paste0(dir_cpp,"MetropolisC.cpp"))
n <- 4 #degrees of freedom for target Student t dist.
N <- 2000
sigma <- 2
x0 <- 25
MR <- MetropolisR(sigma,x0,N)$x[-(1:500)]
MetropolisR <- function(n, sigma, x0, N) {
f <- function(x) {
return(exp(-abs(x))/2)
}
x <- numeric(N)
x[1] <- x0
u <- runif(N)
k <- 0
for (i in 2:N) {
y <- rnorm(1, x[i-1], sigma)
if (u[i] <= (f(y) / f(x[i-1])))
x[i] <- y else {
x[i] <- x[i-1]
k <- k + 1
}
}
return(list(x=x, k=k))
}
MR <- MetropolisR(sigma,x0,N)$x[-(1:500)]
MR <- MetropolisR(n,sigma,x0,N)$x[-(1:500)]
MC <- MetropolisC(sigma,x0,N)[-(1:500)]
qqplot(rwR,rwC)
qqplot(MC, MR)
abline(a=0,b=1,col='black')
library(microbenchmark)
times <- microbenchmark(MC=MetropolisC(sigma,x0,N), MR=MetropolisR(n,sigma,x0,N))
t <- summary(times1)
t <- summary(times)
t
devtools::document()
rm(list = c("boot.BCa", "MetropolisC", "MetropolisR", "pwr_t", "sk"))
devtools::document()
devtools::build_vignettes()
## refer to TA
library(MASS)
set.seed(7912)
set.seed(7912)
## refer to TA
library(MASS)
mu1 <- mu2 <- c(0,0,0)
sigma1 <- matrix(c(1,0,0,0,1,0,0,0,1),nrow=3,ncol=3)
sigma2 <- matrix(c(100,0,0,0,100,0,0,0,100),nrow=3,ncol=3)
sigma=list(sigma1,sigma2)
m=1000
n=50
#m: number of replicates; n: sample size
epsilon <- c(seq(0, .06, .01), seq(.1, 1, .05))
N <- length(epsilon)
pwr <- numeric(N)
for (j in 1:N) { #for each epsilon
e <- epsilon[j]
sktests <- numeric(m)
for (i in 1:m) { #for each replicate
index=sample(c(1, 2), replace = TRUE, size = n, prob = c(1-e, e))
mydata<-matrix(0,nrow=n,ncol=3)
for(t in 1:n){
if(index[t]==1) mydata[t,]=mvrnorm(1,mu1,sigma1)
else mydata[t,]=mvrnorm(1,mu2,sigma2)
}
sktests[i] <- Mardia(mydata)
}
pwr[j] <- mean(sktests)
}
for (j in 1:N) { #for each epsilon
e <- epsilon[j]
sktests <- numeric(m)
for (i in 1:m) { #for each replicate
index=sample(c(1, 2), replace = TRUE, size = n, prob = c(1-e, e))
mydata<-matrix(0,nrow=n,ncol=3)
for(t in 1:n){
if(index[t]==1) mydata[t,]=mvrnorm(1,mu1,sigma1)
else mydata[t,]=mvrnorm(1,mu2,sigma2)
}
sktests[i] <- Mardia.test(mydata)
}
pwr[j] <- mean(sktests)
}
plot(epsilon, pwr, type = "b",
xlab = bquote(epsilon), ylim = c(0,1))
plot(epsilon, pwr, type = "b",
xlab = bquote(epsilon), ylim = c(0,1))
abline(h = .05, lty = 3)
se <- sqrt(pwr * (1-pwr) / m) #add standard errors
lines(epsilon, pwr+se, lty = 3)
lines(epsilon, pwr-se, lty = 3)
plot(epsilon, pwr, type = "b",
xlab = bquote(epsilon), ylim = c(0,1))
abline(h = .05, lty = 3)
se <- sqrt(pwr * (1-pwr) / m) #add standard errors
lines(epsilon, pwr+se, lty = 3)
lines(epsilon, pwr-se, lty = 3)
## jackknife estimate of the bias and standard error
b.cor <- function(x,i) cor(x[i,1],x[i,2])
data(law, package = "bootstrap")
x <- as.matrix(law)
n <- nrow(law)
theta.hat <- cor(law$LSAT, law$GPA)
theta.jack <- numeric(n)
for(i in 1:n){
theta.jack[i] <- b.cor(x,(1:n)[-i])
}
bias.jack <- (n-1)*(mean(theta.jack)-theta.hat)
se.jack <- sqrt((n-1) * mean((theta.jack - mean(theta.jack))^2))
round(c(original=theta.hat, bias.jack=bias.jack, se.jack=se.jack), 3)
boot.BCa <-
function(x, th0, th, stat, conf = .95) {
# bootstrap with BCa bootstrap confidence interval
# th0 is the observed statistic
# th is the vector of bootstrap replicates
# stat is the function to compute the statistic
x <- as.matrix(x)
n <- nrow(x) #observations in rows
N <- 1:n
alpha <- (1 + c(-conf, conf))/2
zalpha <- qnorm(alpha)
# the bias correction factor
z0 <- qnorm(sum(th < th0) / length(th))
# the acceleration factor (jackknife est.)
th.jack <- numeric(n)
for (i in 1:n) {
J <- N[1:(n-1)]
th.jack[i] <- stat(x[-i, ], J)
}
L <- mean(th.jack) - th.jack
a <- sum(L^3)/(6 * sum(L^2)^1.5)
# BCa conf. limits
adj.alpha <- pnorm(z0 + (z0+zalpha)/(1-a*(z0+zalpha)))
limits <- quantile(th, adj.alpha, type=6)
return(list("est"=th0, "BCa"=limits))
}
library(boot) #for boot and boot.ci
data("aircondit", package = "boot")
dat <- as.matrix(aircondit)
theta.hat <- mean(dat)
theta.boot <- function(dat, ind) {
x <- dat[ind, 1]
#function to compute the statistic
mean(x)
}
boot.obj <- boot(dat, statistic = theta.boot, R = 2000)
alpha <- c(.025, .975)
#normal
print(boot.obj$t0 + qnorm(alpha) * sd(boot.obj$t))
#basic
print(2*boot.obj$t0 - quantile(boot.obj$t, rev(alpha), type=1))
#percentile
print(quantile(boot.obj$t, alpha, type=6))
#BCa
boot.BCa(x, th0 = mean(dat), th = boot.obj$t, stat = theta.boot)
data("scor", package = "bootstrap")
ev <- eigen(cov(scor))$values
theta.hat <- ev[1]/sum(ev)
x <- as.matrix(scor)
n <- nrow(scor)
theta.jack <- numeric(n)
for(i in 1:n){
x1 <- x[-i, ]
ev <- eigen(cov(x1))$values
theta.jack[i] <- ev[1]/sum(ev)
}
bias.jack <- (n-1)*(mean(theta.jack)-theta.hat)
se.jack <- sqrt((n-1) * mean((theta.jack - mean(theta.jack))^2))
round(c(original=theta.hat, bias.jack=bias.jack, se.jack=se.jack), 3)
knitr::opts_chunk$set(echo = TRUE)
library(lattice)
library(DAAG)
attach(ironslag)
devtools::build_vignettes()
.Last.error.trace
library(boot)
library(energy)
library(Ball)
library(RANN)
Tn <- function(z, ix, sizes,k) {
n1 <- sizes[1]; n2 <- sizes[2]; n <- n1 + n2
if(is.vector(z)) z <- data.frame(z,0);
z <- z[ix, ];
NN <- nn2(data=z, k=k+1) # what's the first column?
block1 <- NN$nn.idx[1:n1,-1]
block2 <- NN$nn.idx[(n1+1):n,-1]
i1 <- sum(block1 < n1 + .5); i2 <- sum(block2 > n1+.5)
(i1 + i2) / (k * n)
}
eqdist.nn <- function(z,sizes,k){
boot.obj <- boot(data=z,statistic=Tn,R=R,
sim = "permutation", sizes = sizes,k=k)
ts <- c(boot.obj$t0,boot.obj$t)
p.value <- mean(ts>=ts[1])
list(statistic=ts[1],p.value=p.value)
}
m <- 1e3; k<-3; p<-2; mu <- 0.5; sigma = 1.2; set.seed(12345)
n1 <- n2 <- 50; R<-999; n <- n1+n2; N = c(n1,n2)
p.values <- matrix(NA,m,3)
for(i in 1:m){
x <- matrix(rnorm(n1));
y <- matrix(rnorm(n2,sd=sigma));
z <- rbind(x,y)
p.values[i,1] <- eqdist.nn(z,N,k)$p.value
p.values[i,2] <- eqdist.etest(z,sizes=N,R=R)$p.value
p.values[i,3] <- bd.test(x=x,y=y,R=999,seed=i*12345)$p.value
}
alpha <- 0.1;
pow1 <- colMeans(p.values<alpha)
pow1
p.values <- matrix(NA,m,3)
for(i in 1:m){
x <- matrix(rnorm(n1,mean=mu));
y <- matrix(rnorm(n2,sd=sigma));
z <- rbind(x,y)
p.values[i,1] <- eqdist.nn(z,N,k)$p.value
p.values[i,2] <- eqdist.etest(z,sizes=N,R=R)$p.value
p.values[i,3] <- bd.test(x=x,y=y,R=999,seed=i*12345)$p.value
}
n1=n2=20
n <- n1+n2
N = c(n1,n2)
k=3
R=999
m=100
set.seed(1234)
p.values <- matrix(NA,m,3)
for(i in 1:m){
mydata1 <- as.matrix(rt(n1,1,2),ncol=1)
mydata2 <- as.matrix(rt(n2,2,5),ncol=1)
mydata <- rbind(mydata1,mydata2)
p.values[i,1] <- eqdist.nn(mydata,N,k)$p.value
p.values[i,2] <- eqdist.etest(mydata,sizes=N,R=R)$p.value
p.values[i,3] <- bd.test(x=mydata1,y=mydata2,num.permutations=R,seed=i*2846)$p.value
}
alpha <- 0.05;
pow3 <- colMeans(p.values<alpha)
pow3
f <- function(x) {
return(exp(-abs(x))/2)
}
MetropolisR <- function(n, sigma, x0, N) {
x <- numeric(N)
x[1] <- x0
u <- runif(N)
k <- 0
for (i in 2:N) {
y <- rnorm(1, x[i-1], sigma)
if (u[i] <= (f(y) / f(x[i-1])))
x[i] <- y else {
x[i] <- x[i-1]
k <- k + 1
}
}
return(list(x=x, k=k))
}
n <- 4 #degrees of freedom for target Student t dist.
N <- 2000
sigma <- c(.05, .5, 2, 16)
x0 <- 25
rw1 <- MetropolisR(n, sigma[1], x0, N)
rw2 <- MetropolisR(n, sigma[2], x0, N)
rw3 <- MetropolisR(n, sigma[3], x0, N)
rw4 <- MetropolisR(n, sigma[4], x0, N)
#number of candidate points rejected
print(1-c(rw1$k, rw2$k, rw3$k, rw4$k)/N) ## acceptance rate
par(mfrow=c(2,2))  #display 4 graphs together
rw <- cbind(rw1$x, rw2$x, rw3$x,  rw4$x)
for (j in 1:4) {
plot(rw[,j], type="l",
xlab=bquote(sigma == .(round(sigma[j],3))),
ylab="X", ylim=range(rw[,j]))
}
par(mfrow=c(1,1)) #reset to default
devtools::build_vignettes()
devtools::document()
rm(list = c("boot.BCa", "MetropolisR", "theta.boot"))
devtools::document()
devtools::build_vignettes()
devtools::document()
devtools::build_vignettes()
devtools::document()
devtools::build_vignettes()
knitr::opts_chunk$set(echo = TRUE)
library(lattice)
library(DAAG)
attach(ironslag)
f <- function(x) {
return(exp(-abs(x))/2)
}
MetropolisR <- function(n, sigma, x0, N) {
x <- numeric(N)
x[1] <- x0
u <- runif(N)
k <- 0
for (i in 2:N) {
y <- rnorm(1, x[i-1], sigma)
if (u[i] <= (f(y) / f(x[i-1])))
x[i] <- y else {
x[i] <- x[i-1]
k <- k + 1
}
}
return(list(x=x, k=k))
}
n <- 4 #degrees of freedom for target Student t dist.
N <- 2000
sigma <- c(.05, .5, 2, 16)
x0 <- 25
rw1 <- MetropolisR(n, sigma[1], x0, N)
rw2 <- MetropolisR(n, sigma[2], x0, N)
rw3 <- MetropolisR(n, sigma[3], x0, N)
rw4 <- MetropolisR(n, sigma[4], x0, N)
#number of candidate points rejected
print(1-c(rw1$k, rw2$k, rw3$k, rw4$k)/N) ## acceptance rate
rw1
plot(rw1)
plot(rw1)
plot(rw1$k, rw1$x)
plot(rw1$x[-(1:500)])
plot(rw2$x[-(1:500)])
plot(rw3$x[-(1:500)])
plot(rw4$x[-(1:500)])
plot(rw1$x[-(1:500)])
rw2
rw1
plot(rw2$x[-(1:500)])
plot(rw3$x[-(1:500)])
plot(rw1$x[-(1:500)],type="l")
plot(rw2$x[-(1:500)],type="l")
plot(rw3$x[-(1:500)],type="l")
plot(rw4$x[-(1:500)],type="l")
devtools::document()
rm(list = c("MetropolisR"))
devtools::document()
devtools::build_vignettes()
devtools::check()
install.packages(MASS)
install.packages("MASS")
install.packages("MASS")
?rt
knitr::opts_chunk$set(echo = TRUE)
library(lattice)
library(DAAG)
attach(ironslag)
data("ironslag", package = "DAAG")
chisq.var.test <- function(x, alpha){
options(digits = 4)
result <- list()
n <- length(x)
v <- var(x)
result$conf.int.var <- c(
(n-1)*v/qchisq(alpha/2, df = n-1, lower.tail = F),
(n-1)*v/qchisq(alpha/2, df = n-1, lower.tail = T)
)
result$conf.int.se <- sqrt(result$conf.int.var)
result
}
cjisq.var.test(rnorm(100),0.05)
chisq.var.test(rnorm(100),0.05)
devtools::document()
rm(list = c("boot.BCa", "chisq.var.test"))
devtools::document()
devtools::build_vignettes()
devtools::check()
devtools::document()
devtools::build_vignettes()
devtools::check()
devtools::build_vignettes()
devtools::check()
ricker <- function(nzero, r, K=1, time=100, from=0, to=time) {
N <- numeric(time+1)
N[1] <- nzero
for (i in 1:time) N[i+1] <- N[i]*exp(r*(1 - N[i]/K))
Time <- 0:time
plot(Time, N, type="l", xlim=c(from, to))
}
layout(matrix(1:3, 3, 1))
ricker(0.1, 1); title("r = 1")
ricker(0.1, 2); title("r = 2")
ricker(0.1, 3); title("r = 3")
devtools::check()
